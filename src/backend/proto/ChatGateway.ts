// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "ChatGateway.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// Types. 

/**
 * @generated from protobuf message Profile
 */
export interface Profile {
    /**
     * @generated from protobuf field: string displayName = 1;
     */
    displayName: string;
    /**
     * @generated from protobuf field: string icon = 2;
     */
    icon: string;
}
/**
 * @generated from protobuf message Channel
 */
export interface Channel {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string icon = 3;
     */
    icon: string;
    /**
     * @generated from protobuf field: repeated Profile members = 4;
     */
    members: Profile[];
    /**
     * @generated from protobuf field: repeated Message last_messages = 5;
     */
    lastMessages: Message[];
    /**
     * @generated from protobuf field: repeated Conversation conversations = 6;
     */
    conversations: Conversation[];
}
/**
 * @generated from protobuf message Conversation
 */
export interface Conversation {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: bool has_call = 3;
     */
    hasCall: boolean;
    /**
     * @generated from protobuf field: repeated Profile participants = 4;
     */
    participants: Profile[];
    /**
     * @generated from protobuf field: repeated Message messages = 5;
     */
    messages: Message[];
}
/**
 * @generated from protobuf message Message
 */
export interface Message {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: Profile sender = 2;
     */
    sender?: Profile;
    /**
     * @generated from protobuf field: string content = 3;
     */
    content: string;
    /**
     * @generated from protobuf field: int64 timestamp = 4;
     */
    timestamp: bigint;
}
// Packet messages. 

/**
 * @generated from protobuf message AuthenticateCsReq
 */
export interface AuthenticateCsReq {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * @generated from protobuf message AuthenticateScRsp
 */
export interface AuthenticateScRsp {
    /**
     * @generated from protobuf field: Retcode retcode = 1;
     */
    retcode: Retcode;
    /**
     * @generated from protobuf field: string displayName = 2;
     */
    displayName: string;
}
/**
 * @generated from protobuf message MessageScNotify
 */
export interface MessageScNotify {
    /**
     * @generated from protobuf field: string channel_id = 1;
     */
    channelId: string;
    /**
     * @generated from protobuf field: string conversation_id = 2;
     */
    conversationId: string;
    /**
     * @generated from protobuf field: Message message = 3;
     */
    message?: Message;
    /**
     * @generated from protobuf field: Action action = 4;
     */
    action: Action;
}
/**
 * @generated from protobuf message ChannelScNotify
 */
export interface ChannelScNotify {
    /**
     * @generated from protobuf field: Channel channel = 1;
     */
    channel?: Channel;
    /**
     * @generated from protobuf field: Action action = 2;
     */
    action: Action;
}
/**
 * @generated from protobuf enum Retcode
 */
export enum Retcode {
    /**
     * @generated from protobuf enum value: SUCCESS = 0;
     */
    SUCCESS = 0,
    /**
     * @generated from protobuf enum value: GENERAL_FAILURE = 1;
     */
    GENERAL_FAILURE = 1,
    /**
     * Authentication
     *
     * @generated from protobuf enum value: AUTH_BAD_CREDS = 100;
     */
    AUTH_BAD_CREDS = 100
}
/**
 * @generated from protobuf enum Action
 */
export enum Action {
    /**
     * @generated from protobuf enum value: CREATE = 0;
     */
    CREATE = 0,
    /**
     * @generated from protobuf enum value: UPDATE = 1;
     */
    UPDATE = 1,
    /**
     * @generated from protobuf enum value: DELETE = 2;
     */
    DELETE = 2,
    /**
     * @generated from protobuf enum value: UPDATE_LAST = 3;
     */
    UPDATE_LAST = 3
}
/**
 * @generated from protobuf enum PacketIds
 */
export enum PacketIds {
    /**
     * @generated from protobuf enum value: _AuthenticateCsReq = 0;
     */
    _AuthenticateCsReq = 0,
    /**
     * @generated from protobuf enum value: _AuthenticateScRsp = 1;
     */
    _AuthenticateScRsp = 1,
    /**
     * @generated from protobuf enum value: _MessageScNotify = 2;
     */
    _MessageScNotify = 2,
    /**
     * @generated from protobuf enum value: _ChannelScNotify = 3;
     */
    _ChannelScNotify = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Profile$Type extends MessageType<Profile> {
    constructor() {
        super("Profile", [
            { no: 1, name: "displayName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Profile>): Profile {
        const message = { displayName: "", icon: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Profile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Profile): Profile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string displayName */ 1:
                    message.displayName = reader.string();
                    break;
                case /* string icon */ 2:
                    message.icon = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Profile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string displayName = 1; */
        if (message.displayName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.displayName);
        /* string icon = 2; */
        if (message.icon !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.icon);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Profile
 */
export const Profile = new Profile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Channel$Type extends MessageType<Channel> {
    constructor() {
        super("Channel", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "members", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Profile },
            { no: 5, name: "last_messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Message },
            { no: 6, name: "conversations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Conversation }
        ]);
    }
    create(value?: PartialMessage<Channel>): Channel {
        const message = { id: "", name: "", icon: "", members: [], lastMessages: [], conversations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Channel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Channel): Channel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string icon */ 3:
                    message.icon = reader.string();
                    break;
                case /* repeated Profile members */ 4:
                    message.members.push(Profile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Message last_messages */ 5:
                    message.lastMessages.push(Message.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Conversation conversations */ 6:
                    message.conversations.push(Conversation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Channel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string icon = 3; */
        if (message.icon !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.icon);
        /* repeated Profile members = 4; */
        for (let i = 0; i < message.members.length; i++)
            Profile.internalBinaryWrite(message.members[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated Message last_messages = 5; */
        for (let i = 0; i < message.lastMessages.length; i++)
            Message.internalBinaryWrite(message.lastMessages[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated Conversation conversations = 6; */
        for (let i = 0; i < message.conversations.length; i++)
            Conversation.internalBinaryWrite(message.conversations[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Channel
 */
export const Channel = new Channel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Conversation$Type extends MessageType<Conversation> {
    constructor() {
        super("Conversation", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "has_call", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "participants", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Profile },
            { no: 5, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Message }
        ]);
    }
    create(value?: PartialMessage<Conversation>): Conversation {
        const message = { id: "", name: "", hasCall: false, participants: [], messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Conversation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Conversation): Conversation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool has_call */ 3:
                    message.hasCall = reader.bool();
                    break;
                case /* repeated Profile participants */ 4:
                    message.participants.push(Profile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Message messages */ 5:
                    message.messages.push(Message.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Conversation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool has_call = 3; */
        if (message.hasCall !== false)
            writer.tag(3, WireType.Varint).bool(message.hasCall);
        /* repeated Profile participants = 4; */
        for (let i = 0; i < message.participants.length; i++)
            Profile.internalBinaryWrite(message.participants[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated Message messages = 5; */
        for (let i = 0; i < message.messages.length; i++)
            Message.internalBinaryWrite(message.messages[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Conversation
 */
export const Conversation = new Conversation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Message$Type extends MessageType<Message> {
    constructor() {
        super("Message", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sender", kind: "message", T: () => Profile },
            { no: 3, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Message>): Message {
        const message = { id: "", content: "", timestamp: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* Profile sender */ 2:
                    message.sender = Profile.internalBinaryRead(reader, reader.uint32(), options, message.sender);
                    break;
                case /* string content */ 3:
                    message.content = reader.string();
                    break;
                case /* int64 timestamp */ 4:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* Profile sender = 2; */
        if (message.sender)
            Profile.internalBinaryWrite(message.sender, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string content = 3; */
        if (message.content !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.content);
        /* int64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Message
 */
export const Message = new Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticateCsReq$Type extends MessageType<AuthenticateCsReq> {
    constructor() {
        super("AuthenticateCsReq", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticateCsReq>): AuthenticateCsReq {
        const message = { token: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthenticateCsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticateCsReq): AuthenticateCsReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticateCsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AuthenticateCsReq
 */
export const AuthenticateCsReq = new AuthenticateCsReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticateScRsp$Type extends MessageType<AuthenticateScRsp> {
    constructor() {
        super("AuthenticateScRsp", [
            { no: 1, name: "retcode", kind: "enum", T: () => ["Retcode", Retcode] },
            { no: 2, name: "displayName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticateScRsp>): AuthenticateScRsp {
        const message = { retcode: 0, displayName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthenticateScRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticateScRsp): AuthenticateScRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Retcode retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* string displayName */ 2:
                    message.displayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticateScRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Retcode retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* string displayName = 2; */
        if (message.displayName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.displayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AuthenticateScRsp
 */
export const AuthenticateScRsp = new AuthenticateScRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageScNotify$Type extends MessageType<MessageScNotify> {
    constructor() {
        super("MessageScNotify", [
            { no: 1, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "conversation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "message", T: () => Message },
            { no: 4, name: "action", kind: "enum", T: () => ["Action", Action] }
        ]);
    }
    create(value?: PartialMessage<MessageScNotify>): MessageScNotify {
        const message = { channelId: "", conversationId: "", action: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageScNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageScNotify): MessageScNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string channel_id */ 1:
                    message.channelId = reader.string();
                    break;
                case /* string conversation_id */ 2:
                    message.conversationId = reader.string();
                    break;
                case /* Message message */ 3:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                case /* Action action */ 4:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageScNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string channel_id = 1; */
        if (message.channelId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.channelId);
        /* string conversation_id = 2; */
        if (message.conversationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.conversationId);
        /* Message message = 3; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Action action = 4; */
        if (message.action !== 0)
            writer.tag(4, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MessageScNotify
 */
export const MessageScNotify = new MessageScNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelScNotify$Type extends MessageType<ChannelScNotify> {
    constructor() {
        super("ChannelScNotify", [
            { no: 1, name: "channel", kind: "message", T: () => Channel },
            { no: 2, name: "action", kind: "enum", T: () => ["Action", Action] }
        ]);
    }
    create(value?: PartialMessage<ChannelScNotify>): ChannelScNotify {
        const message = { action: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelScNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelScNotify): ChannelScNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Channel channel */ 1:
                    message.channel = Channel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* Action action */ 2:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelScNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Channel channel = 1; */
        if (message.channel)
            Channel.internalBinaryWrite(message.channel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Action action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChannelScNotify
 */
export const ChannelScNotify = new ChannelScNotify$Type();
